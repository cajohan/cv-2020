https://zhuanlan.zhihu.com/p/663056120
https://zhuanlan.zhihu.com/p/539148506
https://www.nowcoder.com/feed/main/detail/4f5dc85c56a948e49199ab02442bcb06

概念题：
1. 是什么？
2. 做什么？
3. 解决什么？
4. 优缺点？

区分题：
1. 分别解释
2. 相同点
3. 不同点

实践题：
建议自己实践一下，然后写博客

JS：
1. 数据类型：
6+2
number, string, boolean, null, undefined, Object; bigint, symbol

2. 原型链是什么？
举例：一个普通对象x={}，x会有一个隐藏属性_???_，指向Object.prototype
x._???_ === Object.prototype
数组a=[]，会有Array.prototype,而Array.prototype也会有Object.prototype

解决什么？没有class情况下继承

3. this: call的第一个参数

4. new 做了什么？
 a. 创建一个临时对象
 b. 执行construct函数
 c. this指向临时对象
 d. 原型指向构造函数的原型
 e. 返回这个对象
  创建临时对象/新对象
  绑定原型
  指定 this = 临时对象
  执行构造函数
  返回临时对象

5. 立即执行函数，闭包，类继承，如何实现继承？
声明之后马上执行的函数；自由变量和访问它的函数；使用原型，或者extends，construct；

6. 手写节流防抖
cd；回城被打断；应用场景，提交数据，搜索框提示？
const throttle = (fn,time) => {
  let flag = true
  return (...args)=>{
    if(!flag) {return}
    fn.call(undefined,...args)
    flag = false
    setTimeout(()=>{
      flag = true
    },time)
  }
}
// 简洁版
const throttle = (f, time) => {
  let timer = null
  return (...args)=>{
    if(timer){
      return
    }
    f.call(undefined,...args)
    timer = setTimeout(()=>{
      timer = null
    },time)
  }
}
const debonce = (fn,time) => {
  let timer = null
  return (...args)=>{
    if(timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(()=>{
      fn.call(undefined,...args)
      timer = null
    },time)
  }
}

7. 手写发布订阅
设计模式，即写代码套路。
函数首先关注输入输出。
映射，map,表，哈希表。任务队列=>函数先进先出
数据结构>算法
const eventHub = {
  queueMap: {},
  on: (name.fn) => {
    // 入队
    // 防御式编程
    eventHub.queueMap[name]=eventHub.queueMap[name]||[]
    eventHub.queueMap[name].push(fn)
    return undefined
  },
  emit: (name, data) => {
    const q = eventHub.map[name]
    if(!q) return
    q.map( f => f(data))
    return undefined
  },
  off: (name,fn) => {
    // 缩写/别名。alias; 只读不写
    const q = eventHub.map[name]
    if(!q){ return }
    const index = q.indexOf(fn)
    // 短路法，少写一个else
    if(index<0) {return}
    q.splice(index,1)
    return undefined
  },
  once: (name,fn)=>{
    const one = (...args)=>{
      fn(...args)
      eventHub.off('click',fn)
    }
    eventHub.on('click',one)
  }
}

eventHub.on('click',f1)
eventHub.off('click',f1)

setTimeout(()=>{
  eventHub.emit('click','frank)
},3000)

也可以用class：
class EventHub {
  map = {}
  on(name, fn) {
    this.map[name] = this.map[name] || []
    this.map[name].push(fn)
  }
  emit(name, data) {
    const fnList = this.map[name] || []
    fnList.forEach(fn => fn.call(undefined, data))
  }
  off(name, fn) {
    const fnList = this.map[name] || []
    const index = fnList.indexOf(fn)
    if(index < 0) return
    fnList.splice(index, 1)
  }
}
// 使用
const e = new EventHub()
e.on('click', (name)=>{
  console.log('hi '+ name)
})
e.on('click', (name)=>{
  console.log('hello '+ name)
})
setTimeout(()=>{
  e.emit('click', 'frank')
},3000)

8. 手写AJAX
Axios，Jquery，VueResource， window.fetch
封装

var xhr = new XMLHttpRequest()

xhr.open('GET', '/xxx')
xhr.onload = () => {}
xhr.onerror = () => {}

// 答案
xhr.onreadystatechage = function(){

}
xhr.send('{"name": "frank"}')

const ajax = (method, url, data, success, fail) => {
  var request = new XMLHttpRequest()
  request.open(method, url);
  request.onreadystatechange = function () {
    if(request.readyState === 4) {
      if(request.status >= 200 && request.status < 300 || request.status === 304) {
        success(request)
      }else{
        fail(request)
      }
    }
  };
  request.send();
}

9. 简版Promise，Promise.all
简版Promise:
class Promise2 {
  #status = 'pending'
  constructor(fn){
    this.q = []
    const resolve= (data) => {
      this.#status = 'fulfilled'
      const f1f2 = this.q.shift()
      if(!f1f2||!f1f2[0]) return
      const x = f1f2[0].call(undefined,data)
      if(x instanceof Promise2) {
        x.then((data)=>{
          resolve(data)
        },(r)=>{
          reject(r)
        })
      }else {
        resolve(x)
      }
    }
    const reject = (r) => {
      this.#status = 'rejected'
      const f1f2 = this.q.shift()
      if(!f1f2||!f1f2[0]) return
      const x = f1f2[1].call(undefined,data)
      if(x instanceof Promise2) {
        x.then((data)=>{
          resolve(data)
        },(r)=>{
          reject(r)
        })
      }else {
        resolve(x)
      }
    }
    fn.call(undefined, resolve, reject)
  }
  then(f1,f2){
    this.q.push([f1,f2])
  }
}
const p = new Promise2((res,rej) => {
  setTimeout(()=>{
    reject('wrong')
  },3000)
})

p.then((data)=>{console.log(data)},(r)=>{console.log(r)})

Promise.all:
1. 知道要在 Promise 上写而不是在原型上写
2. 知道 all 的参数（Promise 数组）和返回值（新 Promise 对象）
3. 知道用数组来记录结果
4. 知道只要有一个 reject 就整体 reject
Promise.myAll = function(list){
  const results = []
  let count = 0
  return new Promise((res,rej)=>{
    list.map((promise,index)=>{
      promise.then(res=>{
        results[index] = res
        count += 1
        if(count>=list.length){
          resolve(results)
        }
      }.rej=>{reject(rej)})
    })
  })
}
新vue2/2；工程化/2

10. 手写深拷贝
new Map()的key可以是对象

11. 数组去重
使用Set，Map

12. Dom

13. 事件委托
e.target和e.currentTarget //current是监听对象
14. 手写拖拽div

15. get和post的区别
幂等性
区别一：幂等性
由于 GET 是读，POST 是写，所以 GET 是幂等的，POST 不是幂等的。
由于 GET 是读，POST 是写，所以用浏览器打开网页会发送 GET 请求，想要 POST 打开网页要用 form 标签。
由于 GET 是读，POST 是写，所以 GET 打开的页面刷新是无害的，POST 打开的页面刷新需要确认。
由于 GET 是读，POST 是写，所以 GET 结果会被缓存，POST 结果不会被缓存。
由于 GET 是读，POST 是写，所以 GET 打开的页面可被书签收藏，POST 打开的不行。
区别二：请求参数
通常，GET 请求参数放在 url 里，POST 请求数据放在 body（消息体）里。（这里注意老师的讲解）
GET 比 POST 更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。（xjb扯）
GET 请求参数放在 url 里是有长度限制的，而 POST 放在 body 里没有长度限制。（xjb扯）
区别三：TCP packet
GET 产生一个 TCP 数据包；POST 产生两个或以上 TCP 数据包。

16. http缓存
	          缓存（强缓存）	内容协商（弱缓存）
HTTP 1.1	Cache-Control: max-age=3600 Etag: ABC	If-None-Match: ABC 响应状态码：304 或 200
HTTP 1.0	Expires: Wed, 21 Oct 2015 02:30:00 GMT Last-Modified: Wed, 21 Oct 2015 01:00:00 GMT	If-Modified-Since: Wed, 21 Oct 2015 01:00:00 GMT 响应状态码：304 或 200
面试官可能还会提到 Pragma ，但 MDN 已经明确不推荐使用它。
17. http和https

HTTPS = HTTP + SSL/TLS（安全层）
区别列表
HTTP 是明文传输的，不安全；HTTPS 是加密传输的，非常安全。
HTTP 使用 80 端口，HTTPS 使用 443 端口。
HTTP 较快，HTTPS 较慢。
HTTPS 的证书一般需要购买（但也有免费的），HTTP 不需要证书。

18. TCP三次握手和四次挥手
建立 TCP 连接时 server 与 client 会经历三次握手
浏览器向服务器发送 TCP 数据：SYN(seq=x)
服务器向浏览器发送 TCP 数据：ACK(seq=x+1) SYN(y)
浏览器向服务器发送 TCP 数据：ACK(seq=y+1)
关闭 TCP 连接时 server 与 client 会经历四次挥手
浏览器向服务器发送 TCP 数据：FIN(seq=x)
服务器向浏览器发送 TCP 数据：ACK(seq=x+1)
服务器向浏览器发送 TCP 数据：FIN(seq=y)
浏览器向服务器发送 TCP 数据：ACK(seq=y+1)
为什么 2、3 步骤不合并起来呢？看起来是脱裤子放屁。

答案：2、3 中间服务器很可能还有数据要发送，不能提前发送 FIN。

19. 同源和跨域
1. JSONP
只能get；没有认证；改动小
2. CORS 

20. Cookie，Session，LS，SS的区别
Cookie V.S. LocalStorage
主要区别是 Cookie 会被发送到服务器，而 LocalStorage 不会
Cookie 一般最大 4k，LocalStorage 可以用 5Mb 甚至 10Mb（各浏览器不同）
LocalStorage V.S. SessionStorage
LocalStorage 一般不会自动过期（除非用户手动清除）
SessionStorage 在回话结束时过期（如关闭浏览器之后，具体由浏览器自行决定）
Cookie V.S. Session
Cookie 存在浏览器的文件里，Session 存在服务器的文件里
Session 是基于 Cookie 实现的，具体做法就是把 SessionID 存在 Cookie 里

21. TS和JS
a. TS 和 JS 的区别是什么？有什么优势？
语法层面：TypeScript = JavaScript + Type（TS 是 JS 的超集）
执行环境层面：浏览器、Node.js 可以直接执行 JS，但不能执行 TS（Deno 可以执行 TS）
编译层面：TS 有编译阶段，JS 没有编译阶段（只有转译阶段和 lint 阶段）
编写层面：TS 更难写一点，但是类型更安全
文档层面：TS 的代码写出来就是文档，IDE 可以完美提示。JS 的提示主要靠 TS

b. any、unknown、never 的区别是什么？
any V.S. unknown
二者都是顶级类型（top type），任何类型的值都可以赋值给顶级类型变量：

let foo: any = 123; // 不报错
let bar: unknown = 123; // 不报错
但是 unknown 比 any 的类型检查更严格，any 什么检查都不做，unknown 要求先收窄类型：

const value: unknown = "Hello World";
const someString: string = value; 
// 报错：Type 'unknown' is not assignable to type 'string'.(2322)
const value: unknown = "Hello World";
const someString: string = value as string; // 不报错
如果改成 any，基本在哪都不报错。所以能用 unknown 就优先用 unknown，类型更安全一点。

never
never 是底类型，表示不应该出现的类型，这里有一个尤雨溪给出的例子：

interface A {
  type: 'a'
}

interface B {
  type: 'b'
}

type All = A | B

function handleValue(val: All) {
  switch (val.type) {
    case 'a':
      // 这里 val 被收窄为 A
      break
    case 'b':
      // val 在这里是 B
      break
    default:
      // val 在这里是 never
      const exhaustiveCheck: never = val
      break
  }
}

c. type 和 interface 的区别是什么？
官方给出的文档说明：

组合方式：interface 使用 extends 来实现继承，type 使用 & 来实现联合类型。
扩展方式：interface 可以重复声明用来扩展，type 一个类型只能声明一次
范围不同：type 适用于基本类型，interface 一般不行。
命名方式：interface 会创建新的类型名，type 只是创建类型别名，并没有新创建类型。

d. TS 工具类型 Partial、Required、Readonly、Exclude、Extract、Omit、ReturnType 的作用和实现？
将英文翻译为中文。
Partial 部分类型
Required 必填类型
Readonly 只读类型
Exclude 排除类型
Extract 提取类型
Pick/Omit 排除 key 类型
ReturnType 返回值类型
举例说明每个工具类型的用法。

22. Vue 2
a. Vue 2 的生命周期钩子有哪些？数据请求放在哪个钩子？
Vue 2 文档写得很清楚，红色空心框中的文字皆为生命周期钩子：

create x 2 (before + ed) - SSR
mount x 2
update x 2
destroy x 2
还有三个写在钩子列表里：

activated
deactivated
errorCaptured
请求放在 mounted 里面，因为放在其他地方都不合适（xjb扯）。

b. Vue 2 组件间通信方式有哪些？
父子组件：使用「props 和事件」进行通信
爷孙组件：
使用两次父子组件间通信来实现
使用「provide + inject」来通信
任意组件：使用 eventBus = new Vue() 来通信
主要API 是 eventBus.$on 和 eventBus.$emit
缺点是事件多了就很乱，难以维护
任意组件：使用 Vuex 通信（Vue 3 可用 Pinia 代替 Vuex）

c. Vuex 用过吗？怎么理解？
背下文档第一句：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库
说出核心概念的名字和作用：store/State/Getter/Mutation/Action/Module
store 是个大容器，包含以下所有内容
State 用来读取状态，带有一个 mapState 辅助函数
Getter 用来读取派生状态，附有一个 mapGetters 辅助函数
Mutation 用于同步提交状态变更，附有一个 mapMutations 辅助函数
Action 用于异步变更状态，但它提交的是 mutation，而不是直接变更状态。
Module 用来给 store 划分模块，方便维护代码
常见追问：Mutation 和 Action 为什么要分开？

答案：为了让代码更易于维护。（可是 Pinia 就把 Mutation 和 Action 合并了呀）

完。

d. VueRouter 用过吗？怎么理解？
背下文档第一句：Vue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举。
说出核心概念的名字和作用：router-link router-view 嵌套路由、Hash 模式和 History 模式、导航守卫、懒加载
常见追问：
Hash 模式和 History 模式的区别？
一个用的 Hash，一个用的 History API
一个不需要后端 nginx 配合，一个需要
导航守卫如何实现登录控制？
router.beforeEach((to, from, next) => {
  if (to.path === '/login') return next()
  if (to是受控页面 && 没有登录) return next('/login')
  next()
})

e. Vue 2 是如何实现双向绑定的？
说明一般使用 v-model / .sync 实现，`v-model` 是 v-bind:value 和 v-on:input 的语法糖
v-bind:value 实现了 data ⇒ UI 的单向绑定
v-on:input 实现了 UI ⇒ data 的单向绑定
加起来就是双向绑定了
这两个单向绑定是如何实现的呢？
前者通过 Object.defineProperty API 给 data 创建 getter 和 setter，用于监听 data 的改变，data 一变就会安排改变 UI
后者通过 template compiler 给 DOM 添加事件监听，DOM input 的值变了就会去修改 data。
网上的博客讲得很绕，你可以尝试理解看看。

