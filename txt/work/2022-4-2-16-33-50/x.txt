节流
const throttle = (fn,time)=>{
  let timer = null
  return (...args)=>{
    if(timer) return
    fn(...args)
    timer = setTimeout(()=>{
      timer = null
    },time)
  }
}

防抖
const debounce = (fn,time)=>{
  let timer = null
  return (...args)=>{
    clearTimeout(timer)
    timer = setTimeout(()=>{
      fn(...args)
    },time)
  }
}

自我介绍
面试官您好，我叫xxx，毕业于xxx学校xxx专业，本科学历。我在上一份工作中主要负责小程序和H5的开发，使用Taro+React技术栈，参与了三款微信小程序的开发、维护与发版，同时也负责了项目中的前端H5部分。在项目中，我曾面临过挑战，比如...，我通过...的方式成功解决了这个问题。

此外，我熟悉Vue，最近的个人项目使用Vue+TSX完成。我还取得了大学英语六级证书，具备良好的英语读写能力。在业余时间，我有写技术博客的习惯，主要在知乎更新，曾分享过关于使用webstorm的经验，阅读量数万。我认为自己是一个对技术充满热情、有着丰富前端经验的人，期待能够为贵公司做出更多贡献。谢谢！

React常用的hooks？
useState，useEffect，useRef，useContext
useMemo:
用于记忆计算值，避免在每次渲染时重新计算。
useRef:
用于获取 DOM 元素或保存可变值。
useReducer:
用于在组件中使用复杂的状态逻辑。
useCallback：
用于记忆回调函数，防止函数在每次渲染时重新创建。

XSS和CSRF？
XSS（Cross Site Script），指跨站脚本攻击。
攻击者脚本 嵌入 被攻击网站，获取用户cookie等隐私信息。
CSRF(Cross Site Request Forgery)指的是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。跨域指的是请求来源于其他网站，伪造指的是非用户自身的意愿。
已登录用户 访问 攻击者网站，攻击网站向被攻击网站发起恶意请求（利用浏览器会自动携带cookie）。

父组件更新了，子组件没更新，子组件会重新渲染吗？
正常是不会的，通过VDOM比较有变动才更新。

在前端路由中，有两种常见的模式：Hash 模式和History 模式。
Hash 模式：
实现方式： 在 URL 中使用哈希（#）来管理路由，例如 http://example.com/#/path。
优点： 兼容性好，因为哈希部分不会被发送到服务器，不会触发页面重新加载。
缺点： 带有 # 符号，不够美观；同时，前端获取路由需要通过监听 hashchange 事件等方式。
History 模式：
实现方式： 利用 HTML5 的 History API，通过 pushState 和 replaceState 可以在不重新加载页面的情况下改变 URL。
优点： URL 更美观，不带 # 符号；前端路由使用起来更像传统的后端路由。
缺点： 兼容性较差，不支持的浏览器需要有备用方案；需要服务器的支持，以避免在刷新页面或直接访问 URL 时返回 404。

12.6：

v-if和v-show的区别？
尬住了，一时没想出来。其实字面意思就是了，if表示有没有，show通过css表示展示与否。

Axios怎么封装的？
TS泛型体操，Axios怎么写返回的参数。
type GetConfig = Omit<AxiosRequestConfig, 'params' | 'url' | 'method'>
type PostConfig = Omit<AxiosRequestConfig, 'url' | 'data' | 'method'>
type PatchConfig = Omit<AxiosRequestConfig, 'url' | 'data'>
type DeleteConfig = Omit<AxiosRequestConfig, 'params'>

export class Http {
  instance: AxiosInstance
  constructor(baseURL: string) {
    this.instance = axios.create({
      baseURL
    })
  }
  get<R = unknown>(url: string, query?: Record<string, JSONValue>, config?: GetConfig) {
    return this.instance.request<R>({ ...config, url: url, params: query, method: 'get' })
  }
  post<R = unknown>(url: string, data?: Record<string, JSONValue>, config?: PostConfig) {
    return this.instance.request<R>({ ...config, url, data, method: 'post' })
  }
  patch<R = unknown>(url: string, data?: Record<string, JSONValue>, config?: PatchConfig) {
    return this.instance.request<R>({ ...config, url, data, method: 'patch' })
  }
  delete<R = unknown>(url: string, query?: Record<string, string>, config?: DeleteConfig) {
    return this.instance.request<R>({ ...config, url: url, params: query, method: 'delete' })
  }
}
在上面提到的代码片段中，<R = unknown> 表示该函数 post 使用了泛型 R，并且默认类型是 unknown。这意味着你可以在使用该函数时，显式指定返回类型，如 post<MyResponseType>(url, data, config)，也可以省略类型参数，此时将使用默认的 unknown 类型。这样的设计提高了函数的灵活性，让它适用于不同类型的返回数据。

protobuff

docker一般怎么用？
docker build
docker run

喉咙不舒服导致胃口不好，但是还是要好好吃饭，按时吃饭吖...


从输入 URL 到展现页面的全过程可以分为以下步骤：

域名解析（DNS Resolution）：
浏览器首先需要将用户输入的域名转换为对应的 IP 地址。这一过程由域名系统（DNS）完成。浏览器首先会检查本地缓存中是否有对应域名的 IP 地址，如果没有，就会向 DNS 服务器发出请求。
建立 TCP 连接（TCP Handshake）：

通过 DNS 解析得到目标服务器的 IP 地址后，浏览器需要和服务器建立 TCP 连接。这是一个三次握手的过程，包括客户端发出连接请求，服务器回应同意连接，最后客户端发送确认。
发起 HTTP 请求：

通过建立的 TCP 连接，浏览器向服务器发送 HTTP 请求。请求中包括请求行（URL、HTTP 方法等）、请求头（包含浏览器信息、客户端支持的压缩算法等）和请求体（对于 POST 请求）。
服务器处理请求：

服务器接收到请求后，根据请求的内容和服务器上的资源，进行相应的处理。这可能涉及到数据库查询、业务逻辑处理等。
服务器返回响应：

服务器处理完请求后，会返回一个 HTTP 响应。响应中包括状态行（表示请求成功或失败的状态码）、响应头（包含服务器信息、内容类型等）和响应体（实际的数据内容）。
浏览器渲染页面：

浏览器接收到服务器返回的响应后，开始解析 HTML、CSS 和 JavaScript。然后构建 DOM 树、CSSOM 树，并将它们合并成渲染树。最终通过布局和绘制阶段完成页面的渲染。
页面加载完毕：

当页面中的所有资源（图片、样式表、脚本等）都加载完成后，页面加载完毕。此时触发 DOMContentLoaded 事件，表示 DOM 树已经构建完成，可以操作 DOM 了。
关闭 TCP 连接：

最后，浏览器和服务器之间的 TCP 连接可以被关闭。这是一个四次挥手的过程，包括客户端发出连接结束请求，服务器回应确认，服务器发出连接结束通知，客户端回应确认。
这是一个简化的描述，实际过程中可能还涉及到缓存机制、安全性检查、重定向等额外步骤。


C/S 架构（Client/Server Architecture）和 B/S 架构（Browser/Server Architecture）是两种不同的软件架构模型，它们主要区分在于客户端和服务器之间的关系。

除了违法犯罪的事情，尽量不做否定发言。 ——某网友

